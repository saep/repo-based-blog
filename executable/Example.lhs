Example Page
============

This source file is an example for a web page using
[happstack, boomerang](http://happstack.com) and
the blog generated by [saeplog](https://github.com/saep/saeplog).

You can see this page because you have run the \texttt{run_example_sandboxed.sh}
script from the cloned github repository. If that is not the case, then you may
be on a web page run by somebody else who has run something equivalent to the
script. If that is the case and you want to have this web page running for
yourselt on hardware of your chosing, then check go to
[github](https://github.com/saep/saeplog) and follow the instructions.

This page is generated using the wonderful [pandoc](http://pandoc.org) library
glued together with parts of this blog software. The file it was generated from
is the actual source file for this example written in literate Haskell. As it
is quite tedious to keep documentation and code synchronized with each other,
thes structure of the example is exactly the same as the source file. This may
only lead to outdated documentation, but not to outdated code. For these
reasions, the first snippet of code lists the module name together with some
language pragmas which are needed or convenient for this example. If you are a
beginner in haskell, do not be alarmed by them. They integrate quite nicely
with natural haskell code and mainly remove boilerplate from the source code.
On the first occurence of code where a language pragma is having effect, i will
include a small note with an explanation of what it does.

\begin{code}
{-# LANGUAGE DeriveDataTypeable         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeOperators              #-}
module Example
    ( site
    ) where
\end{code}

As the import statements of a haskell module are required to be after the
module statement, here they are. You can probably ignore them until you want to
know where a function is defined that is used in this example.

\begin{code}
import Web.Saeplog.Blog
import Web.Saeplog.Converter
import Web.Saeplog.Templates.Saep
import Web.Saeplog.Types as T

import Control.Applicative
import Control.Category
import Control.Lens
import Control.Monad.Reader
import Data.Data                   (Data, Typeable)
import Data.Monoid
import Data.Text                   (Text, unpack)
import Happstack.Server
import Data.Maybe
import Data.IxSet                  (fromList)
import Data.Time                   (getCurrentTime)
import Prelude                     hiding (id, (.))
import System.Directory
import System.FilePath             hiding ((</>))
import Text.Blaze.Html5            as H
import Text.Blaze.Html5.Attributes as A hiding (dir, start, id)
import Text.Boomerang              hiding ((.~))
import Text.Boomerang.TH           (makeBoomerangs)
import Web.Routes
import Web.Routes.Boomerang        hiding ((.~))
import Web.Routes.Happstack        ()
\end{code}

Time to define the routes for this example. It has essentially three routes.
They should be self explanatory. This data type definition can later be used to
create URLs to elements on this web site whose validity can mostly be checked
by the compiler. I think this is a goot thing and the main reasion I used the
`web-routes` package with the `boomerang` package.

The data type defintion code snippet that follows this text uses two language
pragmas: DeriveDataTypeable and TemplateHaskell. The former simply allows the
automatic deriving of the `Data` and `Typeable` instance for the data type in
the same way as you would dervive `Read`, `Show` etc. The template haskell bit
is the last line which will do a similar thing for the type classes used by
boomerang. As the boomerang package is not bundled with the Haskell compiler,
it cannot be used via the `deriving` clause.

\begin{code}
data Sitemap
    = Home
    | Blog
    | Resources Text
    deriving (Eq, Ord, Show, Read, Data, Typeable)
$(makeBoomerangs ''Sitemap)
\end{code}

The following code snippet defines the actual paths of each data type
constructor as it will appear in the web browser. It will use another language
pragma, namely: OverloadedStrings. This allows you to put string literals into
your source code that are not necessarily interpreted as the liteal type
`String`. The `Router` builder uses in fact the `Text` type for its arguments
as they are usually more performant than normal `String`s.

The `$(makeBoomerangs ''Sitemap)` snippet has also created three functions for
each of the constructor that allows a magical definion for the routes used in
this example. The first line in the sitemap function (`rHome`) simply defines
that the route at the root of the web page will be equivalet to using `Home`
somewhere in the web page. The third line will map the `Blog` constructor to
the url `/blog`. The second line has even more magic included. It will also
parse the path entry after `resources` and put it in the first (and only) field
of the `Resources` constructor. An example on how to use this will follow
follow shortly. Oh, the TypeExtension language pragma is used here. It's the
`:-` in the type signature. For details, check the docuementation for boomerang.

\begin{code}
sitemap :: Router () (Sitemap :- ())
sitemap =
    rHome
    <> rResources . "resources" </> anyText
    <> rBlog . "blog"
\end{code}

Now we can define the routing function. The type signature may be a bit scary,
but it is just a bunch of monad transformers. The outer transformer is `RouteT`
which does magic with a our `Sitemap` type, is wrapped around another bunch of
monad transformers and has the "return type" `Response`. The monad it is
wrapped around is just a reader monad which gives us access to an element of
type `Options` whenever we want without carring it around explicitly. This one
is wrapped around happstacks `ServerPartT` monad transformer that has an `IO`
at its foot. Apart from looking scary, you get used to transformer stacking if
you use it regularly. It's a really powerful concept. You can also let ghc
infer the types for you, so that you don't have to know them yourself. It does
however help to know and write down the type as you can avoid misleading error
messages in other parts of the code. Anyway, let's just go on.

\begin{code}
type StaticResrouceDirectory = Maybe FilePath

route :: Blog
      -> Sitemap
      -> RouteT Sitemap (ReaderT StaticResrouceDirectory (ServerPartT IO)) Response
route b url = case url of
    Home        -> homePage
    Blog        -> serveBlog b
    Resources f -> serveResourceFile f
\end{code}

The next function serves a file from the resource directory that can be
configuraed via the command line. Type `saeplog -h` for all options and the
syntax to do so. The type obviously mathces that of `route` as we did not lift,
return or bind anything. The first line gets the static resources directory
from the reader state, i.e. the `Options` element. If it is defined, the
happstack instacnce tries to send the file with the proper mime type to the
user. This implementation will not work for nested directories due to the way
the parser in `route` works, though.

\begin{code}
serveResourceFile :: Text
                  -> RouteT Sitemap (ReaderT StaticResrouceDirectory (ServerPartT IO)) Response
serveResourceFile f = do
    maybeResDir <- ask
    case maybeResDir of
        Nothing -> mzero
        Just d  ->
            serveFile (guessContentTypeM mimeTypes) (d <> "/" <> unpack f)
\end{code}

Haskell shines with composability and reuseability. As our last two routes lead
to content with markup, it is just natural to define a template with as many
variables as we want. In this case, I chose two lists of `Html` elements. The
`Html` type is defined in the blaze-html package which allows the creation of
well-typed html while being a pure haskell library. Although it is well typed,
it is not necessarily well-formed as you can combine any elements together. If
you know HTML already, this should not be a big problem to understand. The more
interesting parts of this snippet of code are the first three lines that show
you how to use the web-routes defined above to make relatively type-safe urls.
We essentially call `showURL` somewere in a `RouteT` monad transformer stack to
create the url part. In this example `res <- showURL $ Resources "saep.css"`
would bind the URL "http://127.0.0.1:8000/resources/saep.css" to the name
`res`. The part before "/resources/saep.css" can be configured via a command
line parameter and is by default like the example. Notice that the generic
monadic combinator `sequence_` is used to put the list of html headers into the
document. (I fint that pretty neat.)

\begin{code}
siteTemplate :: (Monad m, Functor m)
             => [Html] -- ^ Additional Headers
             -> [Html] -- ^ Body content
             -> RouteT Sitemap m Html
siteTemplate hs bodyContent = do
    home <- unpack <$> showURL Home
    res <- showURL $ Resources "saep.css"
    blog <- unpack <$> showURL Blog
    return $ do
        docType
        html $ do
            H.head $ do
                meta ! httpEquiv "Content-Type"
                     ! content "text/html;charset=utf-8"
                meta ! content "width=device-width, initial-scale=1, maximum-scale=1"
                     ! name "viewport"
                link ! rel "stylesheet" ! type_ "text/css"
                     ! href (toValue res)
                sequence_ hs
            H.body $ do
                topNavigationBar [ ("Home", Just home)
                                 , ("Blog", Just blog)
                                 , ("Github", Just "https://github.com/saep")
                                 ]
                sequence_ bodyContent
\end{code}

The following function creates the blog entries, puts them in the template and
then creates a Happstack response from it. The blog entries to show are
configured to via command line parameter and beyond the purpose of this article.

\begin{code}
serveBlog :: Blog
          -> RouteT Sitemap (ReaderT StaticResrouceDirectory (ServerPartT IO)) Response
serveBlog blog = do
    entries <- lift . lift $ blogEntries blog
    blogMarkup <- siteTemplate hs entries
    lift . ok . toResponse $ blogMarkup
  where
    hs = [ H.title "Saeptain's log" ]
\end{code}

The homepage should be this page. It is a little complicated as I want to avoid
scanning through the whole repository and the API is still quite specialized.
Take this as an exercise and expect it to be easier in the future. The `Entry`
is usually extracted from the repository, but I fear this may take too long in
the future. (I guess it doesn't matter. But paranoia doesn't mean they're not
after you!)

\begin{code}
homePage :: RouteT Sitemap (ReaderT StaticResrouceDirectory (ServerPartT IO)) Response
homePage = do
    let thisFilePath = "executable/Example.lhs"
    thisExists <- liftIO $ doesFileExist thisFilePath
    case () of
        _ | thisExists -> do
            thisFile <- liftIO $ readFile thisFilePath
            let thisWithMarkup = fileContentToHtml LiterateHaskell thisFile
            let this = withBlogHeader [thisWithMarkup]
            lift . ok . toResponse =<< siteTemplate hs [this]
        _  -> lift . notFound . toResponse $ ()

  where
    hs = [ H.title "Welcome to saeplog's example site"]

\end{code}

Finally we glue this all together and define the only function we have to
export for the main module to work.

\begin{code}
site :: Blog
     -> Site Sitemap (ReaderT StaticResrouceDirectory (ServerPartT IO) Response)
site b = setDefault Home $ boomerangSite (runRouteT (route b)) sitemap
\end{code}

This example may have been way more complicated than using Happstack directly
with simple routes. That example is covered really well in the Happstack
documentation already and this approach should scale pretty well and may serve
as an intermediate tutorial on how to use boomerang together with Happstack.

